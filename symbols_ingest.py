import os
import sys

import hashlib
import tomllib
import argparse

hpp = """// This file is autogenerated. Do not edit directly!
#pragma once
#include <stdint.h>

struct ThunkMetadata
{
    const char* mName;
    const char* mPattern;
    int64_t mOffset;
    uintptr_t* mPointer;
};

#define DX_CREATE_DYNAMIC_THUNK(mangled_symbol, lookup_name, pattern_str, offset) \\
    extern "C" uintptr_t impl_##mangled_symbol; \\
    uintptr_t impl_##mangled_symbol = 0; \\
    \\
    [[gnu::used, gnu::section("dx_thunks")]] \\
    static const ThunkMetadata meta_##mangled_symbol = { \\
        lookup_name, \\
        pattern_str, \\
        offset, \\
        &impl_##mangled_symbol \\
    }; \\
    \\
    extern "C" __attribute__((visibility("hidden"))) void mangled_symbol(); \\
    \\
    __asm__ ( \\
        ".section .text." #mangled_symbol "\\n" \\
        ".global " #mangled_symbol "\\n" \\
        ".hidden " #mangled_symbol "\\n" \\
        ".type " #mangled_symbol ", %function\\n" \\
        #mangled_symbol ":\\n" \\
        "adrp x16, impl_" #mangled_symbol "\\n" \\
        "ldr x16, [x16, #:lo12:impl_" #mangled_symbol "]\\n" \\
        "br x16\\n" \\
    );
"""

thunk = """
DX_CREATE_DYNAMIC_THUNK(
    {},
    "{}",
    "{}",
    {}
)
"""

def check_hash(hash_path: str, current_hash: str) -> bool:
    if not os.path.isfile(hash_path):
        return False

    with open(hash_path, "r", encoding="utf-8") as f:
        existing_hash = f.read().strip()
        return existing_hash == current_hash

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Create a header containing symbol entries.")

    parser.add_argument("input", type=str, help="Path to the symbols.toml file.")
    parser.add_argument("output", type=str, help="Path to the output header file.")
    parser.add_argument("hash", type=str, help="File containing hash of the input file.", default=None)

    args = parser.parse_args()

    # Get path arguments.
    input_path: str = args.input
    output_path: str = args.output
    hash_path: str | None = args.hash

    # Load toml file.
    data = {}
    hash = ""
    with open(input_path, "rb") as f:
        data = tomllib.load(f)
        hash = hashlib.file_digest(f, "sha256").hexdigest()

    # Abort if the hash has not changed.
    if check_hash(hash_path, current_hash=hash):
        print("No changes detected in symbols.toml, skipping generation.")
        sys.exit(0)

    # Store the new hash if there is a difference.
    with open(hash_path, "w", encoding="utf-8") as f:
        f.write(hash)

    # Parse toml.
    symbols = data.get("symbols", None)
    assert symbols is not None, "No symbols section found in toml."

    for symbol in symbols:
        name: str = symbol.get("mangled", None)
        pattern: str = symbol.get("pattern", None)
        offset: int = int(symbol.get("offset", None), 0)

        assert name is not None, "Symbol entry missing name."
        assert pattern is not None, f"Symbol entry {name} missing pattern."

        hpp += str.format(thunk, name, name, pattern, hex(offset))
        
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(hpp)
    